# Deribit Price Tracker

## Оглавление
- [Описание проекта](#описание-проекта)
- [Технологии](#технологии)
- [Установка и запуск проекта](#установка-и-запуск-проекта)
- [Эндпоинты API](#эндпоинты-api)
- [Design Decisions](#design-decisions)


## Описание проекта
Backend-сервис на **FastAPI** для сбора, хранения и предоставления данных о стоимости криптовалют.Приложение периодически получает index price валют BTC_USD и ETH_USD с криптобиржи **Deribit**, сохраняет данные в **PostgreSQL** и предоставляет HTTP API для получения исторических и актуальных цен.

### Возможности

- Получение цен криптовалют с **Deribit API**  
- Сохранение цен в **PostgreSQL**  
- REST API для получения:
  - Последней цены по тикеру  
  - Истории цен по тикеру за период  
  - Всех цен по тикеру  

## Технологии
- Python 3.12
- FastAPI
- PostgreSQL
- Celery
- Redis
- aiohttp
- SQLAlchemy
- Docker, Docker Compose

## Установка и запуск проекта

### Требования
- Python 3.10+ установлен и доступен в PATH  
- Docker и Docker Compose (для запуска контейнеров)  

> На Windows рекомендуется использовать PowerShell, на Linux/macOS - терминал.

### 1. Клонировать репозиторий
```bash
git clone https://github.com/mariapikhtovnikava22/Crypto-Price-Tracker.git
cd Crypto-Price-Tracker
```
---

### 2. Настроить переменные окружения
Создайте файл `.env` в корне проекта и заполните его необходимыми переменными окружения.  
Все необходимые переменные описаны в `.env.example`.

---

### 3. Запуск проекта через Docker Compose
```bash
docker-compose up --build
```

> Swagger UI доступен по адресу: `http://127.0.0.1:8000/docs`  

---

## Эндпоинты API

* **GET /prices/prices_by_ticker?ticker=BTC_USD** - получить все цены по указанному тикеру  
* **GET /prices/latest_price_by_ticker?ticker=BTC_USD** - получить последнюю цену по тикеру  
* **GET /prices/period?ticker=BTC_USD&date_from=1670000000&date_to=1671000000** - получить цены по тикеру за указанный период  

---

### Пример запроса для последней цены
```bash
curl "http://127.0.0.1:8000/prices/latest_price_by_ticker?ticker=BTC_USD"
```

### Пример ответа для последней цены
```json
{
  "ticker": "BTC_USD",
  "price": 50000,
  "created_at": 1670000000
}
```
---

### Пример запроса для всех цен по тикеру
```bash
curl "http://127.0.0.1:8000/prices/prices_by_ticker?ticker=BTC_USD"
```

### Пример ответа для всех цен
```json
{
  "items": [
    {
      "ticker": "BTC_USD",
      "price": 50000,
      "created_at": 1670000000
    },
    {
      "ticker": "BTC_USD",
      "price": 50500,
      "created_at": 1670003600
    }
  ]
}
```

---

### Пример запроса за период
```bash
curl "http://127.0.0.1:8000/prices/period?ticker=BTC_USD&date_from=1670000000&date_to=1671000000"
```

### Пример ответа за период
```json
{
  "items": [
    {
      "ticker": "BTC_USD",
      "price": 50000,
      "created_at": 1670000000
    },
    {
      "ticker": "BTC_USD",
      "price": 50500,
      "created_at": 1670003600
    }
  ]
}
```
---

## Design Decisions

### Асинхронный FastAPI
Проект построен на **FastAPI** с использованием `async/await` для асинхронного выполнения:  
- Асинхронные вызовы позволяют одновременно обрабатывать множество запросов к API Deribit, не блокируя основной поток сервера.  
- Используется **aiohttp** для запросов к внешнему API, что позволяет эффективно работать с сетевыми задержками.  
- Асинхронная работа с базой данных через **SQLAlchemy AsyncSession** обеспечивает масштабируемость и стабильность при высоких нагрузках.

### Чистая архитектура
Проект структурирован по принципам **чистой архитектуры**, чтобы разделить ответственность и обеспечить тестируемость:  

- **Domain / Models** - сущность (`Prices`), полностью независима от технологий.  
- **Application / Services** - сервисы (`PricesService`, `FetchPricesService`) реализуют бизнес-логику, не зависят от FastAPI или базы данных.  
- **Infrastructure / Repositories** - реализация доступа к данным (`PricesRepository`) и интеграции с внешними API (Deribit).  
- **Presentation / API** - слой, который предоставляет внешний интерфейс через FastAPI и одновременно управляет фоновыми задачами Celery, вызывая сервисы для выполнения бизнес-логики.

### Celery для фоновых задач
Выбран **Celery** для периодического получения цен с Deribit:  
- Celery работает **параллельно FastAPI**, не блокируя основной сервер.  
- Все задачи выполняются в отдельных воркерах, что обеспечивает стабильность при высокой частоте запросов к API.  
- Используется Redis как брокер сообщений для очередей задач.  
- Асинхронный FastAPI и Celery интегрированы корректно: сервисы и Unit of Work работают одинаково как в синхронном, так и в асинхронном контексте.

### Unit of Work
Реализован паттерн **Unit of Work** для работы с базой данных:  
- Обеспечивает атомарность операций: все изменения в контексте сохраняются вместе или откатываются при ошибке.  
- Решает проблему согласованности данных при одновременном создании нескольких цен за тикер.  
- Позволяет удобно подставлять мок-репозитории в тестах, имитируя работу с базой без необходимости реальной БД.

### Exception Handlers
- Все исключения проекта централизованно обрабатываются с помощью **FastAPI exception handlers**.  
- Сервисы и клиент Deribit API выбрасывают пользовательские исключения для конкретных сценариев:  
  - `PriceNotFoundError` - если цены не найдены в базе данных.  
  - `TaskDispatchError` - при сбоях отправки или выполнения фоновой задачи Celery.  
- Exception handlers гарантируют, что API возвращает информативные и читаемые ответы клиенту, включая HTTP-код и описание ошибки.

### Dependency Injector
Использовался для управления зависимостями **вне FastAPI**, где `Depends()` недоступен:

- **Celery-задачи**, чтобы корректно создавать сервисы, репозитории и Unit of Work в фоновом процессе, без участия FastAPI.
- Контейнер обеспечивает **единую точку создания объектов**, например, DeribitClient, PricesService, PricesUnitOfWork.
- В Celery задача `fetch_prices_task` использует контейнер для получения всех зависимостей: сервис получает клиент и Unit of Work через контейнер, затем выполняется асинхронная операция внутри цикла событий `asyncio`, что не мешает основному FastAPI.
- Позволяет легко подменять сервисы и репозитории на **моки** в тестах без изменения кода.
- Обеспечивает согласованность зависимостей во всех контекстах приложения: HTTP API, фоновые задачи, асинхронные операции.

### Docker и Docker Compose

Для удобства разворачивания и изоляции зависимостей использовалась контейнеризация:

- **Docker** позволяет запускать **FastAPI**, **Celery**, **PostgreSQL** и **Redis** в отдельных контейнерах.
- **Docker Compose** управляет связью между контейнерами и обеспечивает последовательный запуск сервисов.

Контейнеризация упрощает тестирование и деплой, делает окружение повторяемым на разных машинах.